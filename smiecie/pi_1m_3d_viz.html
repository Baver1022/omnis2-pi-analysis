<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<title>PI – 1M cyfr → pełna analiza XYZ</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body { margin:0; overflow:hidden; background:#000; color:#0ff; font-family:monospace }
#ui {
  position:fixed; top:10px; left:10px;
  background:rgba(0,0,0,0.9);
  border:2px solid #0ff;
  border-radius:5px;
  padding:12px; 
  font-size:11px;
  box-shadow: 0 0 20px rgba(0,255,255,0.3);
  min-width:180px;
  z-index:1000;
}
#status {
  color:#0ff;
  font-weight:bold;
  margin:5px 0;
}
#progress {
  color:#0aa;
  font-size:9px;
  margin-top:3px;
  font-style:italic;
}
button {
  width:100%; 
  margin:3px 0;
  padding:6px;
  background:#000; 
  color:#0ff;
  border:1px solid #0ff; 
  cursor:pointer;
  border-radius:3px;
  transition: all 0.2s;
  font-size:10px;
}
button:hover { 
  background:#0ff; 
  color:#000;
  box-shadow: 0 0 10px rgba(0,255,255,0.5);
  transform: translateX(2px);
}
</style>
</head>
<body>

<div id="ui">
<b>π — 1 000 000 000 cyfr</b><br>
XYZ = kolejne trójki<br>
Punkty: max 10M (próbkowanie)<br>
Prawdziwe cyfry π z plików<br>
<div id="status">Ładowanie...</div>
<div id="progress" style="margin-top:5px; font-size:9px; color:#0aa;"></div>
<br>
<button id="m0">Chmura 3D</button>
<button id="m1">Gęstość voxel</button>
<button id="m2">π vs PRNG</button>
<button id="m3">Projekcja XY</button>
<button id="m4">Projekcja XZ</button>
<button id="m5">Projekcja YZ</button>
<button id="m6">Animacja okna</button>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://esm.sh/three@0.152.2",
    "three/addons/": "https://esm.sh/three@0.152.2/examples/jsm/"
  }
}
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

//////////////////////
// WCZYTYWANIE PRAWDZIWYCH CYFR π Z PLIKÓW pi_10b_parts
//////////////////////
async function loadPiDigits(n) {
  const statusEl = document.getElementById('status');
  
  statusEl.textContent = 'Wczytywanie cyfr π z plików...';
  
  try {
    // Użyj TypedArray zamiast zwykłej tablicy (limit JavaScript)
    const digits = new Uint8Array(n);
    let digitIndex = 0;
    const chunkSize = 100_000_000; // każdy plik ma 100M cyfr
    const filesNeeded = Math.ceil(n / chunkSize);
    
    console.log(`Potrzeba ${filesNeeded} plików dla ${n.toLocaleString()} cyfr`);
    
    // Wczytaj potrzebne pliki
    for (let fileIdx = 0; fileIdx < filesNeeded && digitIndex < n; fileIdx++) {
      const startPos = fileIdx * chunkSize + 1;
      const endPos = Math.min((fileIdx + 1) * chunkSize, n);
      
      // Format nazwy pliku: 1-100000000.txt, 100000001-200000000.txt, itd.
      const fileName = `${startPos}-${endPos}.txt`;
      
      statusEl.textContent = `Wczytywanie pliku ${fileIdx + 1}/${filesNeeded}: ${fileName}...`;
      
      try {
        // Użyj serwera z CORS (port 8001)
        const url = `http://localhost:8001/pi_10b_parts/${fileName}`;
        console.log(`Fetch: ${url}`);
        
        const progressEl = document.getElementById('progress');
        if (progressEl) {
          progressEl.textContent = `Plik ${fileIdx + 1}/${filesNeeded}: ${((fileIdx + 1) / filesNeeded * 100).toFixed(1)}%`;
        }
        
        const response = await fetch(url, {
          method: 'GET',
          headers: {
            'Accept': 'text/plain'
          }
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`HTTP ${response.status}: ${errorText.substring(0, 100)}`);
        }
        
        const piText = await response.text();
        console.log(`Pobrano ${piText.length.toLocaleString()} znaków z ${fileName}`);
        
        const needed = Math.min(piText.length, n - digitIndex);
        
        // Szybka konwersja - tylko cyfry
        for (let i = 0; i < needed && digitIndex < n; i++) {
          const charCode = piText.charCodeAt(i);
          // 48-57 to '0'-'9' w ASCII
          if (charCode >= 48 && charCode <= 57) {
            digits[digitIndex++] = charCode - 48;
          }
        }
        
        console.log(`Po przetworzeniu: ${digitIndex.toLocaleString()} cyfr (cel: ${n.toLocaleString()})`);
        
      } catch (fileError) {
        console.error(`Błąd wczytywania pliku ${fileName}:`, fileError);
        statusEl.textContent = `Błąd: ${fileError.message}`;
        throw fileError; // Przerwij przy błędzie
      }
    }
    
    statusEl.textContent = `Wczytano ${digitIndex.toLocaleString()} cyfr π`;
    const progressEl = document.getElementById('progress');
    if (progressEl) {
      progressEl.textContent = '100% - Gotowe!';
    }
    console.log(`SUKCES: Wczytano ${digitIndex.toLocaleString()} cyfr`);
    
    // Zwróć Uint8Array bezpośrednio (nie konwertuj na Array - za duże)
    return digits.slice(0, digitIndex);
    
  } catch (error) {
    console.error('Błąd wczytywania:', error);
    statusEl.textContent = `BŁĄD: ${error.message}`;
    throw error;
  }
}

//////////////////////
// DATA
//////////////////////
const DIGITS = 1_000_000_000; // 1B cyfr π z plików pi_10b_parts
let d, COUNT, pos, col, posOriginal;

document.getElementById('status').textContent = 'Ładowanie prawdziwych cyfr π...';

(async function() {
  try {
    console.log('Rozpoczynam wczytywanie...');
    d = await loadPiDigits(DIGITS);
    
    console.log(`Wczytano ${d.length} cyfr`);
    
    if (!d || d.length === 0) {
      throw new Error('Nie wczytano żadnych cyfr!');
    }
    
    COUNT = Math.floor(d.length/3);
    console.log(`Możliwe punkty: ${COUNT.toLocaleString()} (z ${d.length} cyfr)`);
    
    if (COUNT === 0) {
      throw new Error(`COUNT = 0! d.length = ${d.length}`);
    }
    
    // Próbkowanie dla dużych zbiorów danych (333M punktów to za dużo)
    const MAX_POINTS = 10_000_000; // maksymalnie 10M punktów dla wydajności
    const sampleRate = COUNT > MAX_POINTS ? Math.ceil(COUNT / MAX_POINTS) : 1;
    const sampledCount = Math.floor(COUNT / sampleRate);
    
    console.log(`Próbkowanie: ${COUNT.toLocaleString()} -> ${sampledCount.toLocaleString()} punktów (rate: 1/${sampleRate})`);
    
    if (sampledCount === 0) {
      throw new Error(`sampledCount = 0! COUNT=${COUNT}, sampleRate=${sampleRate}`);
    }
    
    document.getElementById('status').textContent = `Przetwarzanie ${sampledCount.toLocaleString()} punktów (próbkowanie 1/${sampleRate})...`;
    
    pos = new Float32Array(sampledCount*3);
    posOriginal = new Float32Array(sampledCount*3);
    col = new Float32Array(sampledCount*3);
    
    // Zoptymalizowana pętla z próbkowaniem
    const dLen = d.length;
    let outIdx = 0;
    const step = sampleRate;
    
    console.log(`Tworzenie punktów: dLen=${dLen}, step=${step}, sampledCount=${sampledCount}`);
    
    for(let i=0; i<COUNT && outIdx < sampledCount; i += step){
      const idx = i*3;
      if (idx+2 >= dLen) {
        console.warn(`Przerwano: idx=${idx}, dLen=${dLen}`);
        break;
      }
      
      const x = d[idx] ?? 0;
      const y = d[idx+1] ?? 0;
      const z = d[idx+2] ?? 0;
      
      pos[outIdx*3] = posOriginal[outIdx*3] = x;
      pos[outIdx*3+1] = posOriginal[outIdx*3+1] = y;
      pos[outIdx*3+2] = posOriginal[outIdx*3+2] = z;
      
      // Kolorowe punkty - żywe kolory w zależności od wartości XYZ
      // Użyj HSV do lepszych kolorów
      const hue = ((x + y + z) / 27.0) * 360; // 0-360
      const sat = 0.8 + (x % 3) * 0.1; // 0.8-1.0
      const val = 0.7 + (y % 3) * 0.2; // 0.7-1.0
      
      // Konwersja HSV -> RGB
      const c = val * sat;
      const x_h = c * (1 - Math.abs((hue / 60) % 2 - 1));
      const m = val - c;
      
      let r, g, b;
      if (hue < 60) { r = c; g = x_h; b = 0; }
      else if (hue < 120) { r = x_h; g = c; b = 0; }
      else if (hue < 180) { r = 0; g = c; b = x_h; }
      else if (hue < 240) { r = 0; g = x_h; b = c; }
      else if (hue < 300) { r = x_h; g = 0; b = c; }
      else { r = c; g = 0; b = x_h; }
      
      col[outIdx*3] = r + m;
      col[outIdx*3+1] = g + m;
      col[outIdx*3+2] = b + m;
      outIdx++;
    }
    
    COUNT = outIdx; // użyj faktycznej liczby utworzonych punktów
    
    console.log(`Utworzono ${COUNT.toLocaleString()} punktów 3D`);
    
    if (COUNT === 0) {
      throw new Error('Nie utworzono żadnych punktów! Sprawdź dane.');
    }
    
    document.getElementById('status').textContent = `Gotowe! ${COUNT.toLocaleString()} punktów 3D`;
    const progressEl = document.getElementById('progress');
    if (progressEl) {
      progressEl.textContent = `Renderowanie wizualizacji...`;
    }
    
    // Inicjalizuj Three.js po załadowaniu danych
    console.log('Dane załadowane:', {COUNT, dLen: d.length, posLen: pos.length});
    if (typeof initThree === 'function') {
      initThree();
      if (progressEl) {
        progressEl.textContent = 'Wizualizacja gotowa!';
      }
    } else {
      console.error('initThree nie jest zdefiniowana!');
      setTimeout(() => {
        if (typeof initThree === 'function') {
          initThree();
        }
      }, 100);
    }
    
  } catch(e) {
    document.getElementById('status').textContent = 'Błąd: ' + e.message;
    console.error('Błąd główny:', e);
    console.error(e.stack);
  }
})();

//////////////////////
// THREE
//////////////////////
let scene, camera, renderer, controls, geo, mat, pts, box;

function initThree() {
  console.log('initThree wywołana, sprawdzam dane...', {pos: !!pos, COUNT, posLen: pos ? pos.length : 0});
  if (!pos || COUNT === 0) {
    console.log('Brak danych, czekam...');
    setTimeout(initThree, 100);
    return;
  }
  console.log('Inicjalizacja Three.js...');
  
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000); // czarne tło

  // Dodaj więcej światła dla lepszej widoczności
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
  scene.add(ambientLight);
  const pointLight1 = new THREE.PointLight(0xff00ff, 1.5, 100);
  pointLight1.position.set(10, 10, 10);
  scene.add(pointLight1);
  const pointLight2 = new THREE.PointLight(0x00ffff, 1.5, 100);
  pointLight2.position.set(-10, -10, -10);
  scene.add(pointLight2);

  camera = new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,1000);
  camera.position.set(12,12,12);
  camera.lookAt(4.5,4.5,4.5);

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(innerWidth,innerHeight);
  document.body.appendChild(renderer.domElement);

  controls = new OrbitControls(camera,renderer.domElement);
  controls.target.set(4.5,4.5,4.5);
  controls.enableDamping=true;

  geo = new THREE.BufferGeometry();
  geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color',new THREE.BufferAttribute(col,3));

  // Większy rozmiar punktów dla lepszej widoczności
  const pointSize = COUNT > 5_000_000 ? 0.4 : 0.6;
  mat = new THREE.PointsMaterial({
    size: pointSize, 
    vertexColors: true,
    transparent: true, 
    opacity: 1.0,
    sizeAttenuation: true
  });

  pts = new THREE.Points(geo,mat);
  scene.add(pts);

  // Jaśniejszy box z lepszą widocznością
  const boxGeometry = new THREE.BoxGeometry(10,10,10);
  const boxEdges = new THREE.EdgesGeometry(boxGeometry);
  const boxLine = new THREE.LineSegments(boxEdges, new THREE.LineBasicMaterial({color: 0x00ffff, linewidth: 2}));
  boxLine.position.set(4.5,4.5,4.5);
  scene.add(boxLine);
  
  console.log('Three.js zainicjalizowane, uruchamianie animacji...');
  animate();
}

//////////////////////
// MODES
//////////////////////
function resetProjection(){
  for(let i=0;i<COUNT;i++){
    pos[i*3] = posOriginal[i*3];
    pos[i*3+1] = posOriginal[i*3+1];
    pos[i*3+2] = posOriginal[i*3+2];
  }
  geo.attributes.position.needsUpdate=true;
}

function setProjection(mode){
  for(let i=0;i<COUNT;i++){
    if(mode==="XY") pos[i*3+2]=0;
    if(mode==="XZ") pos[i*3+1]=0;
    if(mode==="YZ") pos[i*3]=0;
  }
  geo.attributes.position.needsUpdate=true;
}

function density(){
  const vox = new Array(1000).fill(0);
  for(let i=0;i<COUNT;i++){
    const x=pos[i*3],y=pos[i*3+1],z=pos[i*3+2];
    vox[x*100+y*10+z]++;
  }
  const max=Math.max(...vox);
  for(let i=0;i<COUNT;i++){
    const v=vox[pos[i*3]*100+pos[i*3+1]*10+pos[i*3+2]]/max;
    col[i*3]=v; col[i*3+1]=0; col[i*3+2]=1-v;
  }
  geo.attributes.color.needsUpdate=true;
}

//////////////////////
// UI
//////////////////////
document.getElementById('m0').onclick=()=>{
  resetProjection();
  for(let i=0;i<COUNT;i++){
    col[i*3] = col[i*3+1] = col[i*3+2] = 0.8;
  }
  geo.attributes.color.needsUpdate=true;
};
document.getElementById('m1').onclick=density;
document.getElementById('m3').onclick=()=>setProjection("XY");
document.getElementById('m4').onclick=()=>setProjection("XZ");
document.getElementById('m5').onclick=()=>setProjection("YZ");

//////////////////////
// ANIMATE
//////////////////////
let t=0;
let animInterval = null;
document.getElementById('m6').onclick=()=>{
  if(animInterval) {
    clearInterval(animInterval);
    animInterval = null;
    resetProjection();
    return;
  }
  animInterval = setInterval(()=>{
    t=(t+3)%d.length;
    for(let i=0;i<COUNT;i++){
      const idx = (i*3+t) % d.length;
      pos[i*3]=d[idx];
      pos[i*3+1]=d[(idx+1)%d.length];
      pos[i*3+2]=d[(idx+2)%d.length];
    }
    geo.attributes.position.needsUpdate=true;
  },200);
};

function animate(){
  requestAnimationFrame(animate);
  if(controls && renderer && scene && camera) {
    controls.update();
    renderer.render(scene,camera);
  }
}

addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>


