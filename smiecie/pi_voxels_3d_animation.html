<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<title>Animacja 3D Voxeli  z Numeracj</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600&display=swap" rel="stylesheet">
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body {
  font-family: 'Rajdhani', 'Courier New', monospace;
  background: linear-gradient(135deg, #000000 0%, #001122 50%, #000000 100%);
  color: #0ff;
  overflow: hidden;
  position: relative;
}
body::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: 
    radial-gradient(circle at 20% 50%, rgba(0,255,255,0.03) 0%, transparent 50%),
    radial-gradient(circle at 80% 50%, rgba(255,0,255,0.03) 0%, transparent 50%);
  pointer-events: none;
  z-index: 0;
}
#container {
  width: 100vw;
  height: 100vh;
  position: relative;
  z-index: 1;
}
#ui {
  position: fixed;
  top: 20px;
  left: 20px;
  background: linear-gradient(135deg, rgba(0,17,34,0.95) 0%, rgba(0,51,68,0.95) 100%);
  border: 2px solid #0ff;
  border-radius: 12px;
  padding: 20px;
  z-index: 1000;
  min-width: 280px;
  box-shadow: 
    0 0 30px rgba(0,255,255,0.4),
    inset 0 0 20px rgba(0,255,255,0.1);
  backdrop-filter: blur(10px);
}
#ui h2 {
  color: #0ff;
  font-size: 22px;
  margin-bottom: 15px;
  font-family: 'Orbitron', monospace;
  font-weight: 700;
  text-shadow: 0 0 10px rgba(0,255,255,0.8);
  letter-spacing: 1px;
}
#ui label {
  display: block;
  color: #0aa;
  font-size: 13px;
  margin: 12px 0 6px 0;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
#ui input[type="range"] {
  width: 100%;
  margin: 8px 0;
  height: 6px;
  background: rgba(0,255,255,0.2);
  border-radius: 3px;
  outline: none;
  -webkit-appearance: none;
}
#ui input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 18px;
  height: 18px;
  background: #0ff;
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 0 10px rgba(0,255,255,0.8);
  transition: all 0.3s;
}
#ui input[type="range"]::-webkit-slider-thumb:hover {
  background: #0aa;
  box-shadow: 0 0 15px rgba(0,255,255,1);
  transform: scale(1.2);
}
#ui input[type="range"]::-moz-range-thumb {
  width: 18px;
  height: 18px;
  background: #0ff;
  border-radius: 50%;
  cursor: pointer;
  border: none;
  box-shadow: 0 0 10px rgba(0,255,255,0.8);
}
#ui span {
  color: #0ff;
  font-weight: 600;
  font-size: 14px;
  margin-left: 10px;
}
#ui select {
  width: 100%;
  background: rgba(0,51,68,0.8);
  border: 1px solid #0ff;
  color: #0ff;
  padding: 8px 12px;
  border-radius: 6px;
  font-family: 'Rajdhani', monospace;
  font-size: 13px;
  cursor: pointer;
  outline: none;
  transition: all 0.3s;
}
#ui select:hover {
  background: rgba(0,68,85,0.9);
  box-shadow: 0 0 10px rgba(0,255,255,0.3);
}
#ui select:focus {
  border-color: #0aa;
  box-shadow: 0 0 15px rgba(0,255,255,0.5);
}
#ui input[type="checkbox"] {
  width: 20px;
  height: 20px;
  cursor: pointer;
  accent-color: #0ff;
}
#ui button {
  background: linear-gradient(135deg, #003344 0%, #004455 100%);
  border: 2px solid #0ff;
  color: #0ff;
  padding: 10px 18px;
  border-radius: 8px;
  cursor: pointer;
  font-family: 'Rajdhani', monospace;
  font-size: 13px;
  font-weight: 600;
  margin: 8px 8px 8px 0;
  transition: all 0.3s;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  box-shadow: 0 4px 15px rgba(0,255,255,0.2);
}
#ui button:hover {
  background: linear-gradient(135deg, #004455 0%, #005566 100%);
  box-shadow: 0 0 20px rgba(0,255,255,0.6);
  transform: translateY(-2px);
}
#ui button:active {
  transform: translateY(0);
  box-shadow: 0 2px 10px rgba(0,255,255,0.4);
}
#info {
  position: fixed;
  bottom: 20px;
  left: 20px;
  background: linear-gradient(135deg, rgba(0,17,34,0.95) 0%, rgba(0,51,68,0.95) 100%);
  border: 2px solid #0ff;
  border-radius: 12px;
  padding: 15px 20px;
  font-size: 13px;
  z-index: 1000;
  box-shadow: 
    0 0 30px rgba(0,255,255,0.4),
    inset 0 0 20px rgba(0,255,255,0.1);
  backdrop-filter: blur(10px);
  min-width: 250px;
}
#info div {
  margin: 5px 0;
  color: #0aa;
  font-weight: 400;
}
#info span {
  color: #0ff;
  font-weight: 700;
  font-size: 15px;
  text-shadow: 0 0 10px rgba(0,255,255,0.8);
}
#details {
  position: fixed;
  top: 50%;
  right: 20px;
  transform: translateY(-50%);
  background: linear-gradient(135deg, rgba(0,17,34,0.95) 0%, rgba(0,51,68,0.95) 100%);
  border: 2px solid #0ff;
  border-radius: 12px;
  padding: 20px;
  z-index: 1000;
  min-width: 300px;
  max-width: 400px;
  display: none;
  box-shadow: 
    0 0 30px rgba(0,255,255,0.4),
    inset 0 0 20px rgba(0,255,255,0.1);
  backdrop-filter: blur(10px);
}
#details.visible {
  display: block;
  animation: slideIn 0.3s ease-out;
}
@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(-50%) translateX(20px);
  }
  to {
    opacity: 1;
    transform: translateY(-50%) translateX(0);
  }
}
#details h3 {
  color: #0ff;
  font-family: 'Orbitron', monospace;
  font-size: 18px;
  margin-bottom: 15px;
  text-shadow: 0 0 10px rgba(0,255,255,0.8);
  border-bottom: 2px solid #0ff;
  padding-bottom: 10px;
}
#details .detail-item {
  margin: 12px 0;
  padding: 10px;
  background: rgba(0,255,255,0.05);
  border-left: 3px solid #0ff;
  border-radius: 4px;
}
#details .detail-label {
  color: #0aa;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 5px;
}
#details .detail-value {
  color: #0ff;
  font-size: 16px;
  font-weight: 600;
}
</style>
</head>
<body>
<div id="container"></div>

<div id="ui">
  <h2> Voxele  3D</h2>
  <label>Prdko obrotu:</label>
  <input type="range" id="rotationSpeed" min="0" max="2" step="0.1" value="0.5">
  <span id="speedValue">0.5</span>
  
  <label>Rozmiar voxeli:</label>
  <input type="range" id="voxelSize" min="0.5" max="2" step="0.1" value="1">
  <span id="sizeValue">1.0</span>
  
  <label>Pokazuj etykiety:</label>
  <input type="checkbox" id="showLabels" checked>
  
  <label>Kolor wedug:</label>
  <select id="colorMode">
    <option value="count">Liczba punkt贸w</option>
    <option value="coords">Wsp贸rzdne</option>
    <option value="matrix">Macierz</option>
  </select>
  
  <button onclick="toggleAnimation()">革 Pauza</button>
  <button onclick="resetCamera()"> Reset</button>
</div>

<div id="info">
  <div> Voxeli: <span id="voxelCount">0</span></div>
  <div> Punkty: <span id="pointCount">0</span></div>
  <div style="margin-top: 10px; color: #0ff; font-size: 11px;"> Kliknij voxel, aby zobaczy szczeg贸y</div>
</div>

<div id="details">
  <h3>Szczeg贸y Voxela</h3>
  <div id="detailsContent"></div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

let scene, camera, renderer, controls;
let voxelMeshes = [];
let labels = [];
let voxelData = null;
let animationId = null;
let isAnimating = true;
let rotationSpeed = 0.5;
let voxelSize = 1.0;
let showLabels = true;
let selectedVoxel = null;

// Inicjalizacja
function init() {
  // Scene
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);
  
  // Camera
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(15, 15, 15);
  camera.lookAt(0, 0, 0);
  
  // Renderer
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  document.getElementById('container').appendChild(renderer.domElement);
  
  // Controls
  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.minDistance = 5;
  controls.maxDistance = 50;
  
  // Lighting - bardziej dramatyczne
  const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
  scene.add(ambientLight);
  
  // G贸wne wiato
  const light1 = new THREE.DirectionalLight(0xffffff, 1.2);
  light1.position.set(15, 15, 15);
  light1.castShadow = true;
  scene.add(light1);
  
  // Kolorowe wiata dla efektu
  const light2 = new THREE.DirectionalLight(0x00ffff, 0.6);
  light2.position.set(-15, 10, -15);
  scene.add(light2);
  
  const light3 = new THREE.DirectionalLight(0xff00ff, 0.4);
  light3.position.set(10, -15, 10);
  scene.add(light3);
  
  // Point lights dla glow effect
  const pointLight1 = new THREE.PointLight(0x00ffff, 0.5, 50);
  pointLight1.position.set(0, 0, 0);
  scene.add(pointLight1);
  
  // Grid helper - bardziej subtelny
  const gridHelper = new THREE.GridHelper(20, 20, 0x00ffff, 0x001122);
  gridHelper.material.opacity = 0.3;
  gridHelper.material.transparent = true;
  scene.add(gridHelper);
  
  // Axes helper - wikszy
  const axesHelper = new THREE.AxesHelper(12);
  scene.add(axesHelper);
  
  // Fog dla gbi
  scene.fog = new THREE.FogExp2(0x000000, 0.02);
  
  // Event listeners
  window.addEventListener('resize', onWindowResize);
  renderer.domElement.addEventListener('click', onVoxelClick);
  
  // UI controls
  document.getElementById('rotationSpeed').addEventListener('input', (e) => {
    rotationSpeed = parseFloat(e.target.value);
    document.getElementById('speedValue').textContent = rotationSpeed.toFixed(1);
  });
  
  document.getElementById('voxelSize').addEventListener('input', (e) => {
    voxelSize = parseFloat(e.target.value);
    document.getElementById('sizeValue').textContent = voxelSize.toFixed(1);
    updateVoxelSizes();
  });
  
  document.getElementById('showLabels').addEventListener('change', (e) => {
    showLabels = e.target.checked;
    updateLabelsVisibility();
  });
  
  document.getElementById('colorMode').addEventListener('change', (e) => {
    updateColors(e.target.value);
  });
  
  // Load data
  loadVoxelData();
}

function loadVoxelData() {
  fetch('pi_voxels_analysis.json')
    .then(response => response.json())
    .then(data => {
      voxelData = data;
      document.getElementById('voxelCount').textContent = data.total_voxels.toLocaleString();
      document.getElementById('pointCount').textContent = data.total_points.toLocaleString();
      createVoxels(data.voxels);
      animate();
    })
    .catch(error => {
      console.error('Bd wczytywania danych:', error);
      alert('Nie mo偶na wczyta danych. Upewnij si, 偶e plik pi_voxels_analysis.json istnieje.');
    });
}

function createVoxels(voxels) {
  // Znajd藕 maksymaln liczb punkt贸w dla normalizacji kolor贸w
  const maxPoints = Math.max(...voxels.map(v => v.point_count));
  
  voxels.forEach((voxel, index) => {
    const coords = voxel.coordinates;
    const x = coords.x - 4.5; // Centruj wok贸 0 (0-9 -> -4.5 do 4.5)
    const y = coords.y - 4.5;
    const z = coords.z - 4.5;
    
    // Geometry
    const geometry = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
    
    // Material - kolor wedug liczby punkt贸w z gradientem
    const intensity = voxel.point_count / maxPoints;
    const hue = 0.5 - intensity * 0.3; // Niebieski -> Cyan -> Zielony
    const saturation = 0.8 + intensity * 0.2;
    const lightness = 0.4 + intensity * 0.4;
    const color = new THREE.Color().setHSL(hue, saturation, lightness);
    
    const material = new THREE.MeshPhongMaterial({
      color: color,
      transparent: true,
      opacity: 0.85,
      emissive: color,
      emissiveIntensity: 0.3 + intensity * 0.3,
      shininess: 100,
      specular: new THREE.Color(0x00ffff)
    });
    
    // Mesh
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(x, y, z);
    mesh.userData = { voxel: voxel, index: index, originalColor: color.clone() };
    scene.add(mesh);
    voxelMeshes.push(mesh);
    
    // Edges - bardziej widoczne
    const edges = new THREE.EdgesGeometry(geometry);
    const line = new THREE.LineSegments(
      edges,
      new THREE.LineBasicMaterial({ 
        color: 0x00ffff, 
        linewidth: 2,
        transparent: true,
        opacity: 0.6
      })
    );
    mesh.add(line);
    
    // Glow effect - halo wok贸 voxela
    const glowGeometry = new THREE.BoxGeometry(voxelSize * 1.1, voxelSize * 1.1, voxelSize * 1.1);
    const glowMaterial = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
      opacity: 0.1,
      side: THREE.BackSide
    });
    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
    mesh.add(glow);
    
    // Label (text sprite) - lepsze
    createLabel(mesh, coords, voxel);
  });
  
  console.log(`Utworzono ${voxelMeshes.length} voxeli`);
}

function createLabel(mesh, coords, voxel) {
  const canvas = document.createElement('canvas');
  const context = canvas.getContext('2d');
  canvas.width = 512;
  canvas.height = 256;
  
  // Gradient background
  const gradient = context.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop(0, 'rgba(0, 17, 34, 0.95)');
  gradient.addColorStop(1, 'rgba(0, 51, 68, 0.95)');
  context.fillStyle = gradient;
  context.fillRect(0, 0, canvas.width, canvas.height);
  
  // Border
  context.strokeStyle = '#0ff';
  context.lineWidth = 3;
  context.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
  
  // Glow effect
  context.shadowColor = '#0ff';
  context.shadowBlur = 20;
  
  // Coordinates
  context.fillStyle = '#0ff';
  context.font = 'Bold 48px Orbitron';
  context.textAlign = 'center';
  context.textBaseline = 'middle';
  context.fillText(`(${coords.x},${coords.y},${coords.z})`, canvas.width / 2, canvas.height / 2 - 30);
  
  // Point count
  context.fillStyle = '#0aa';
  context.font = '600 32px Rajdhani';
  context.fillText(`${voxel.point_count.toLocaleString()} punkt贸w`, canvas.width / 2, canvas.height / 2 + 25);
  
  // Matrix info
  if (voxel.matrix) {
    context.fillStyle = '#0f0';
    context.font = '500 24px Rajdhani';
    context.fillText(`Macierz ${voxel.matrix.dimension}${voxel.matrix.dimension}${voxel.matrix.dimension}`, canvas.width / 2, canvas.height / 2 + 60);
  }
  
  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  const spriteMaterial = new THREE.SpriteMaterial({ 
    map: texture,
    transparent: true,
    alphaTest: 0.1
  });
  const sprite = new THREE.Sprite(spriteMaterial);
  sprite.scale.set(3, 1.5, 1);
  sprite.position.copy(mesh.position);
  sprite.position.y += voxelSize * 0.8;
  sprite.userData = { voxel: voxel };
  
  scene.add(sprite);
  labels.push(sprite);
}

function updateVoxelSizes() {
  voxelMeshes.forEach(mesh => {
    mesh.scale.set(voxelSize, voxelSize, voxelSize);
  });
}

function updateLabelsVisibility() {
  labels.forEach(label => {
    label.visible = showLabels;
  });
}

function updateColors(mode) {
  if (!voxelData) return;
  
  const maxPoints = Math.max(...voxelData.voxels.map(v => v.point_count));
  
  voxelMeshes.forEach((mesh, index) => {
    const voxel = voxelData.voxels[index];
    let color;
    
    switch(mode) {
      case 'count':
        const intensity = voxel.point_count / maxPoints;
        color = new THREE.Color().setHSL(0.5 - intensity * 0.3, 1, 0.5 + intensity * 0.5);
        break;
      case 'coords':
        const coords = voxel.coordinates;
        color = new THREE.Color(
          coords.x / 9,
          coords.y / 9,
          coords.z / 9
        );
        break;
      case 'matrix':
        color = voxel.matrix ? new THREE.Color(0x00ff00) : new THREE.Color(0xff0000);
        break;
    }
    
    mesh.material.color = color;
    mesh.material.emissive = color;
  });
}

function onVoxelClick(event) {
  const mouse = new THREE.Vector2();
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  
  const raycaster = new THREE.Raycaster();
  raycaster.setFromCamera(mouse, camera);
  
  const intersects = raycaster.intersectObjects(voxelMeshes);
  
  if (intersects.length > 0) {
    const clickedMesh = intersects[0].object;
    const voxel = clickedMesh.userData.voxel;
    
    // Reset poprzedniego wyboru
    if (selectedVoxel) {
      selectedVoxel.material.emissiveIntensity = 0.3;
      selectedVoxel.material.opacity = 0.85;
      selectedVoxel.scale.set(voxelSize, voxelSize, voxelSize);
    }
    
    // Zaznacz nowy z animacj
    selectedVoxel = clickedMesh;
    clickedMesh.material.emissiveIntensity = 1.5;
    clickedMesh.material.opacity = 1.0;
    clickedMesh.scale.set(voxelSize * 1.2, voxelSize * 1.2, voxelSize * 1.2);
    
    // Poka偶 szczeg贸y
    showVoxelDetails(voxel);
  } else {
    // Kliknicie w pust przestrze - ukryj szczeg贸y
    document.getElementById('details').classList.remove('visible');
    if (selectedVoxel) {
      selectedVoxel.material.emissiveIntensity = 0.3;
      selectedVoxel.material.opacity = 0.85;
      selectedVoxel.scale.set(voxelSize, voxelSize, voxelSize);
      selectedVoxel = null;
    }
  }
}

// Hover effect
let hoveredVoxel = null;
renderer.domElement.addEventListener('mousemove', (event) => {
  const mouse = new THREE.Vector2();
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  
  const raycaster = new THREE.Raycaster();
  raycaster.setFromCamera(mouse, camera);
  
  const intersects = raycaster.intersectObjects(voxelMeshes);
  
  // Reset poprzedniego hover
  if (hoveredVoxel && hoveredVoxel !== selectedVoxel) {
    hoveredVoxel.material.emissiveIntensity = 0.3;
    hoveredVoxel.scale.set(voxelSize, voxelSize, voxelSize);
  }
  
  if (intersects.length > 0) {
    const hoveredMesh = intersects[0].object;
    if (hoveredMesh !== selectedVoxel && hoveredMesh !== hoveredVoxel) {
      hoveredVoxel = hoveredMesh;
      hoveredMesh.material.emissiveIntensity = 0.8;
      hoveredMesh.scale.set(voxelSize * 1.1, voxelSize * 1.1, voxelSize * 1.1);
      renderer.domElement.style.cursor = 'pointer';
    }
  } else {
    hoveredVoxel = null;
    renderer.domElement.style.cursor = 'default';
  }
});

function showVoxelDetails(voxel) {
  const coords = voxel.coordinates;
  const detailsPanel = document.getElementById('details');
  const detailsContent = document.getElementById('detailsContent');
  
  detailsContent.innerHTML = `
    <div class="detail-item">
      <div class="detail-label">Wsp贸rzdne</div>
      <div class="detail-value">(${coords.x}, ${coords.y}, ${coords.z})</div>
    </div>
    <div class="detail-item">
      <div class="detail-label">Liczba punkt贸w</div>
      <div class="detail-value">${voxel.point_count.toLocaleString()}</div>
    </div>
    <div class="detail-item">
      <div class="detail-label">Tr贸jki cyfr</div>
      <div class="detail-value">${voxel.triplets_count.toLocaleString()}</div>
    </div>
    <div class="detail-item">
      <div class="detail-label">Macierz 3D</div>
      <div class="detail-value">${voxel.matrix ? `${voxel.matrix.dimension}${voxel.matrix.dimension}${voxel.matrix.dimension}` : 'Brak'}</div>
    </div>
    ${voxel.matrix ? `
    <div class="detail-item">
      <div class="detail-label">Status</div>
      <div class="detail-value" style="color: #0f0;">${voxel.matrix_status}</div>
    </div>
    ` : ''}
  `;
  
  detailsPanel.classList.add('visible');
}

function toggleAnimation() {
  isAnimating = !isAnimating;
  const btn = event.target;
  btn.textContent = isAnimating ? '革 Pauza' : '讹 Odtwarzaj';
}

function resetCamera() {
  camera.position.set(15, 15, 15);
  camera.lookAt(0, 0, 0);
  controls.reset();
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
  animationId = requestAnimationFrame(animate);
  
  if (isAnimating) {
    // Pynny obr贸t caej sceny
    scene.rotation.y += rotationSpeed * 0.01;
    scene.rotation.x += rotationSpeed * 0.005;
    
    // Pulsujce wiato
    const time = Date.now() * 0.001;
    const pointLight = scene.children.find(child => child instanceof THREE.PointLight);
    if (pointLight) {
      pointLight.intensity = 0.5 + Math.sin(time * 2) * 0.2;
    }
    
    // Delikatne pulsowanie voxeli
    voxelMeshes.forEach((mesh, index) => {
      if (mesh !== selectedVoxel && mesh !== hoveredVoxel) {
        const pulse = 1 + Math.sin(time * 2 + index * 0.1) * 0.02;
        mesh.material.emissiveIntensity = 0.3 * pulse;
      }
    });
  }
  
  controls.update();
  renderer.render(scene, camera);
}

// Start
init();
</script>
</body>
</html>

